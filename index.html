<!DOCTYPE html>
<html>
<head>
  <title>Draggable Text Graph</title>
  <style>body{margin:0;overflow:hidden}canvas{display:block}</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://threejs.org/examples/js/controls/DragControls.js"></script>
<script>
const scene = new THREE.Scene();

// Camera (just fixed position)
const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 0, 80);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(50,50,50);
scene.add(dir);

// Controls (orbit for viewing)
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Example data (replace with fetch("nodePositions.json") if needed)
const data = [
    { id: 1, label: "Interests", x: 0, y: 0, z: 0 },
    { id: 2, label: "Music", parent: 1, x: 20, y: 10, z: 5 },
    { id: 3, label: "Coding", parent: 1, x: -15, y: -8, z: -10 },
    { id: 4, label: "Design", parent: 1, x: 10, y: -20, z: 8 },
    { id: 5, label: "Piano", parent: 2, x: 30, y: 15, z: 10 }
];

// Load font and build
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
  const nodes = {};
  const objects = []; // draggable nodes
  const edges = [];

  // Make text nodes
  data.forEach(n => {
    const geo = new THREE.TextGeometry(n.label, { font, size: 2, height: 0.3 });
    geo.computeBoundingBox(); geo.center();
    const mat = new THREE.MeshPhongMaterial({ color: 0x00aaff });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(n.x, n.y, n.z);
    scene.add(mesh);

    nodes[n.id] = mesh;
    objects.push(mesh);

    if (n.parent) edges.push([n.parent, n.id]);
  });

  // Make edges
  const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff });
  const lines = edges.map(([aId, bId]) => {
    const geom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    const line = new THREE.Line(geom, lineMat);
    scene.add(line);
    return { line, a: nodes[aId], b: nodes[bId] };
  });

  // DragControls
  const drag = new THREE.DragControls(objects, camera, renderer.domElement);
  drag.addEventListener('dragstart', () => { controls.enabled = false; });
  drag.addEventListener('dragend',   () => { controls.enabled = true; });

  // Animate
  (function animate(){
    requestAnimationFrame(animate);

    // update line endpoints
    lines.forEach(c => {
      const p = c.line.geometry.attributes.position.array;
      p[0]=c.a.position.x; p[1]=c.a.position.y; p[2]=c.a.position.z;
      p[3]=c.b.position.x; p[4]=c.b.position.y; p[5]=c.b.position.z;
      c.line.geometry.attributes.position.needsUpdate = true;
    });

    controls.update();
    renderer.render(scene, camera);
  })();
});

addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Nodes</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.z = 50;

        const spheres = [];
        const lines = []; // Array to hold line objects
        let nodes = [];

        // Define a material for the lines
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });

        // Fetch nodes from server
        fetch("/nodes")
            .then(res => res.json())
            .then(data => {
                nodes = data;
                nodes.forEach(node => {
                    const geometry = new THREE.SphereGeometry(1.5, 16, 16);
                    const material = new THREE.MeshBasicMaterial({ color: 0x00ffcc });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(node.x, node.y, node.z);
                    scene.add(sphere);
                    spheres.push({ mesh: sphere, data: node });
                });

                // Now that all spheres are created, draw lines
                nodes.forEach(node => {
                    if (node.parent) {
                        const childSphere = spheres.find(s => s.data.id === node.id);
                        const parentSphere = spheres.find(s => s.data.id === node.parent);

                        if (childSphere && parentSphere) {
                            const points = [];
                            points.push(childSphere.mesh.position);
                            points.push(parentSphere.mesh.position);

                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, lineMaterial);
                            scene.add(line);
                            lines.push({ child: childSphere, parent: parentSphere, line: line });
                        }
                    }
                });
            });

        // Save new positions after dragging (simplified example)
        window.addEventListener("keydown", (e) => {
            if (e.key === "s") { // press "s" to save
                const updated = spheres.map(s => ({
                    ...s.data,
                    x: s.mesh.position.x,
                    y: s.mesh.position.y,
                    z: s.mesh.position.z
                }));
                fetch("/nodes", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(updated)
                });
                console.log("Saved new positions!");
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            // Update line positions
            lines.forEach(line => {
                const positions = line.line.geometry.attributes.position.array;
                const p1 = line.child.mesh.position;
                const p2 = line.parent.mesh.position;

                positions[0] = p1.x;
                positions[1] = p1.y;
                positions[2] = p1.z;

                positions[3] = p2.x;
                positions[4] = p2.y;
                positions[5] = p2.z;

                line.line.geometry.attributes.position.needsUpdate = true;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

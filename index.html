<!DOCTYPE html>
<html>
<head>
  <title>Three.js Graph with JSON Data</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// === SCENE SETUP ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(50, 50, 50);
scene.add(light);

// === FONT LOADER ===
const loader = new THREE.FontLoader();
loader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(font) {
    
    // Load JSON data
    fetch("nodePositions.json")
        .then(response => response.json())
        .then(data => {
            const nodes = {};
            const edges = [];

            // Create nodes
            data.forEach(node => {
                const geometry = new THREE.TextGeometry(node.label, {
                    font: font,
                    size: 2,
                    height: 0.3
                });
                geometry.computeBoundingBox();
                geometry.center();

                const material = new THREE.MeshPhongMaterial({ color: 0x00aaff });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.set(node.x, node.y, node.z);
                scene.add(mesh);

                nodes[node.id] = mesh;

                // If parent exists, add an edge
                if (node.parent) {
                    edges.push([node.parent, node.id]);
                }
            });

            // Create line material
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const lines = edges.map(([parentId, childId]) => {
                const points = [
                    new THREE.Vector3(),
                    new THREE.Vector3()
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
                return { line, parent: nodes[parentId], child: nodes[childId] };
            });

            // Animate
            function animate() {
                requestAnimationFrame(animate);

                // Update edge positions
                lines.forEach(conn => {
                    const positions = conn.line.geometry.attributes.position.array;
                    positions[0] = conn.parent.position.x;
                    positions[1] = conn.parent.position.y;
                    positions[2] = conn.parent.position.z;

                    positions[3] = conn.child.position.x;
                    positions[4] = conn.child.position.y;
                    positions[5] = conn.child.position.z;

                    conn.line.geometry.attributes.position.needsUpdate = true;
                });

                renderer.render(scene, camera);
            }
            animate();
        });
});

// Resize
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

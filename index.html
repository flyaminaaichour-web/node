<!DOCTYPE html>
<html>
<head>
  <title>Draggable Graph</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://threejs.org/examples/js/controls/DragControls.js"></script>
<script>
// === SCENE SETUP ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 60);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(50, 50, 50);
scene.add(light);

// Controls for camera
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === FONT LOADER ===
const loader = new THREE.FontLoader();
loader.load("https://threejs.org/examples/fonts/helvetiker_regular.typeface.json", function(font) {
    
    fetch("nodePositions.json")
        .then(response => response.json())
        .then(data => {
            const nodes = {};
            const objects = []; // store meshes for dragging
            const edges = [];

            // Create text nodes
            data.forEach(node => {
                const geometry = new THREE.TextGeometry(node.label, {
                    font: font,
                    size: 2,
                    height: 0.3
                });
                geometry.computeBoundingBox();
                geometry.center();

                const material = new THREE.MeshPhongMaterial({ color: 0x00aaff });
                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.set(node.x, node.y, node.z);
                scene.add(mesh);

                nodes[node.id] = mesh;
                objects.push(mesh);

                if (node.parent) {
                    edges.push([node.parent, node.id]);
                }
            });

            // Lines
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            const lines = edges.map(([parentId, childId]) => {
                const points = [new THREE.Vector3(), new THREE.Vector3()];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
                return { line, parent: nodes[parentId], child: nodes[childId] };
            });

            // Drag controls
            const dragControls = new THREE.DragControls(objects, camera, renderer.domElement);

            // Disable orbit while dragging
            dragControls.addEventListener("dragstart", () => { controls.enabled = false; });
            dragControls.addEventListener("dragend", () => { controls.enabled = true; });

            // Animate
            function animate() {
                requestAnimationFrame(animate);

                // Update line positions
                lines.forEach(conn => {
                    const positions = conn.line.geometry.attributes.position.array;
                    positions[0] = conn.parent.position.x;
                    positions[1] = conn.parent.position.y;
                    positions[2] = conn.parent.position.z;
                    positions[3] = conn.child.position.x;
                    positions[4] = conn.child.position.y;
                    positions[5] = conn.child.position.z;
                    conn.line.geometry.attributes.position.needsUpdate = true;
                });

                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        });
});

// Resize
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
